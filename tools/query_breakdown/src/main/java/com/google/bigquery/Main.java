package com.google.bigquery;

import static java.lang.System.exit;

import org.apache.commons.cli.*;

import java.io.IOException;

/**
 * This file is the main file for the command line tool.
 * Usage: query_breakdown -i <PATH> [-j] [-l <INTEGER>]
 * -i, --inputFile, PATH: this command specifies the path to the file containing queries to be
 *                    inputted into the tool. It is therefore mandatory
 * -j, --json: this command specifies whether the program should output the results in a
 *                   json format. It is therefore optional
 * -l, --limit, INTEGER: this command specifies the path to an integer that the tool takes as a
 *                    limit for the number of errors to be explored, thereby controlling the
 *                    runtime. It is therefore optional
 *
 * Sample Usage: query_breakdown -i input.txt
 *               query_breakdown -i input2.txt -j -l 3
 *               query_breakdown -i input3.txt -j
 *               query_breakdown -i input4.txt -l 6
 */
public class Main {
  public static void main(String[] args) {
    String inputFile = null;
    int errorLimit = 0;
    boolean jsonOutput = false;
    CommandLine cl = createCommand(args);

    // if there is an error in parsing the commandline
    if (cl == null) {
      exit(1);
    }

    if (cl.hasOption("i")) {
      inputFile = cl.getOptionValue("i");
    }
    if (cl.hasOption("j")) {
      jsonOutput = true;
    }
    if (cl.hasOption("l")) {
      errorLimit = Integer.parseInt( cl.getOptionValue("l"));
    }

    // this is where we will put the file I/O logic through the input reader.
    String originalQuery = null;
    InputReader ir = new InputReader();
    try {
      originalQuery = ir.readInput(inputFile);
    } catch (IOException e) {
      System.out.println("there was an I/O error while reading the input");
      e.printStackTrace();
      exit(1);
    }

    /* this is where we feed in the original query to QueryBreakdown, which will find
       all the unparseable components of the query and output them into the output file if
       specified. Otherwise, it will be autogenerated.
     */
    QueryBreakdown qb = new QueryBreakdown(new CalciteParser());
    qb.run(originalQuery, jsonOutput, errorLimit, ir.getLocationTracker());
  }

  /**
   * This is the method that instantiates a CommandLine object for the Apache CLI Interface.
   * It deals with command line parsing as well as help generation once parsing is unavailable
   */
  public static CommandLine createCommand(String[] args) {
    CommandLineParser parser = new DefaultParser();
    Options options = createOptions();
    HelpFormatter help = new HelpFormatter();

    CommandLine cl = null;
    try {
      cl = parser.parse(options, args);
    } catch (ParseException e) {
      System.out.println("there was an issue parsing the commandline" + e.getMessage());
      help.printHelp("query_breakdown", options, true);
    }

    return cl;
  }

  /**
   * This is the method that instantiates options for the Apache CLI interface
   */
  public static Options createOptions() {
    Options options = new Options();
    options.addOption(Option.builder("i").required(true).longOpt("inputFile").hasArg(true)
        .argName("PATH").desc("this command specifies the path to the file "
            + "containing queries to be inputted into the tool. It is therefore mandatory")
        .build());
    options.addOption(Option.builder("j").longOpt("json")
            .desc("this command specifies whether the program should output the results in a \n"
                    + "json format. It is therefore optional").build());
    options.addOption(Option.builder("l").longOpt("limit").hasArg(true).argName("INTEGER")
        .desc("this command specifies the path to an integer that the tools takes "
            + "as a limit for the number of errors to be explored, thereby controlling"
            + "the runtime. It is therefore optional").build());
    return options;
  }
}